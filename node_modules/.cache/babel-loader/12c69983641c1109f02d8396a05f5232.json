{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _toArray from \"@babel/runtime/helpers/esm/toArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport warning from \"rc-util/es/warning\";\n\nfunction getKey(data, index) {\n  var key = data.key;\n  var value;\n\n  if ('value' in data) {\n    value = data.value;\n  }\n\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return \"rc-index-key-\".concat(index);\n}\n\nexport function fillFieldNames(fieldNames, childrenAsData) {\n  var _ref = fieldNames || {},\n      label = _ref.label,\n      value = _ref.value,\n      options = _ref.options;\n\n  return {\n    label: label || (childrenAsData ? 'children' : 'label'),\n    value: value || 'value',\n    options: options || 'options'\n  };\n}\n/**\r\n * Flat options into flatten list.\r\n * We use `optionOnly` here is aim to avoid user use nested option group.\r\n * Here is simply set `key` to the index if not provided.\r\n */\n\nexport function flattenOptions(options) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      fieldNames = _ref2.fieldNames,\n      childrenAsData = _ref2.childrenAsData;\n\n  var flattenList = [];\n\n  var _fillFieldNames = fillFieldNames(fieldNames, false),\n      fieldLabel = _fillFieldNames.label,\n      fieldValue = _fillFieldNames.value,\n      fieldOptions = _fillFieldNames.options;\n\n  function dig(list, isGroupOption) {\n    list.forEach(function (data) {\n      var label = data[fieldLabel];\n\n      if (isGroupOption || !(fieldOptions in data)) {\n        var value = data[fieldValue]; // Option\n\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data: data,\n          label: label,\n          value: value\n        });\n      } else {\n        var grpLabel = label;\n\n        if (grpLabel === undefined && childrenAsData) {\n          grpLabel = data.label;\n        } // Option Group\n\n\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data: data,\n          label: grpLabel\n        });\n        dig(data[fieldOptions], true);\n      }\n    });\n  }\n\n  dig(options, false);\n  return flattenList;\n}\n/**\r\n * Inject `props` into `option` for legacy usage\r\n */\n\nexport function injectPropsWithOption(option) {\n  var newOption = _objectSpread({}, option);\n\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get: function get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n\n  return newOption;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n\n  var match = false;\n\n  function separate(str, _ref3) {\n    var _ref4 = _toArray(_ref3),\n        token = _ref4[0],\n        restTokens = _ref4.slice(1);\n\n    if (!token) {\n      return [str];\n    }\n\n    var list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce(function (prevList, unitStr) {\n      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));\n    }, []).filter(function (unit) {\n      return unit;\n    });\n  }\n\n  var list = separate(text, tokens);\n  return match ? list : null;\n}","map":{"version":3,"sources":["C:/Users/tarun/bigbox-home/node_modules/rc-select/es/utils/valueUtil.js"],"names":["_toConsumableArray","_toArray","_objectSpread","warning","getKey","data","index","key","value","undefined","concat","fillFieldNames","fieldNames","childrenAsData","_ref","label","options","flattenOptions","_ref2","arguments","length","flattenList","_fillFieldNames","fieldLabel","fieldValue","fieldOptions","dig","list","isGroupOption","forEach","push","groupOption","grpLabel","group","injectPropsWithOption","option","newOption","Object","defineProperty","get","getSeparatedContent","text","tokens","match","separate","str","_ref3","_ref4","token","restTokens","slice","split","reduce","prevList","unitStr","filter","unit"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\r\nimport _toArray from \"@babel/runtime/helpers/esm/toArray\";\r\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\r\nimport warning from \"rc-util/es/warning\";\r\n\r\nfunction getKey(data, index) {\r\n  var key = data.key;\r\n  var value;\r\n\r\n  if ('value' in data) {\r\n    value = data.value;\r\n  }\r\n\r\n  if (key !== null && key !== undefined) {\r\n    return key;\r\n  }\r\n\r\n  if (value !== undefined) {\r\n    return value;\r\n  }\r\n\r\n  return \"rc-index-key-\".concat(index);\r\n}\r\n\r\nexport function fillFieldNames(fieldNames, childrenAsData) {\r\n  var _ref = fieldNames || {},\r\n      label = _ref.label,\r\n      value = _ref.value,\r\n      options = _ref.options;\r\n\r\n  return {\r\n    label: label || (childrenAsData ? 'children' : 'label'),\r\n    value: value || 'value',\r\n    options: options || 'options'\r\n  };\r\n}\r\n/**\r\n * Flat options into flatten list.\r\n * We use `optionOnly` here is aim to avoid user use nested option group.\r\n * Here is simply set `key` to the index if not provided.\r\n */\r\n\r\nexport function flattenOptions(options) {\r\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n      fieldNames = _ref2.fieldNames,\r\n      childrenAsData = _ref2.childrenAsData;\r\n\r\n  var flattenList = [];\r\n\r\n  var _fillFieldNames = fillFieldNames(fieldNames, false),\r\n      fieldLabel = _fillFieldNames.label,\r\n      fieldValue = _fillFieldNames.value,\r\n      fieldOptions = _fillFieldNames.options;\r\n\r\n  function dig(list, isGroupOption) {\r\n    list.forEach(function (data) {\r\n      var label = data[fieldLabel];\r\n\r\n      if (isGroupOption || !(fieldOptions in data)) {\r\n        var value = data[fieldValue]; // Option\r\n\r\n        flattenList.push({\r\n          key: getKey(data, flattenList.length),\r\n          groupOption: isGroupOption,\r\n          data: data,\r\n          label: label,\r\n          value: value\r\n        });\r\n      } else {\r\n        var grpLabel = label;\r\n\r\n        if (grpLabel === undefined && childrenAsData) {\r\n          grpLabel = data.label;\r\n        } // Option Group\r\n\r\n\r\n        flattenList.push({\r\n          key: getKey(data, flattenList.length),\r\n          group: true,\r\n          data: data,\r\n          label: grpLabel\r\n        });\r\n        dig(data[fieldOptions], true);\r\n      }\r\n    });\r\n  }\r\n\r\n  dig(options, false);\r\n  return flattenList;\r\n}\r\n/**\r\n * Inject `props` into `option` for legacy usage\r\n */\r\n\r\nexport function injectPropsWithOption(option) {\r\n  var newOption = _objectSpread({}, option);\r\n\r\n  if (!('props' in newOption)) {\r\n    Object.defineProperty(newOption, 'props', {\r\n      get: function get() {\r\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\r\n        return newOption;\r\n      }\r\n    });\r\n  }\r\n\r\n  return newOption;\r\n}\r\nexport function getSeparatedContent(text, tokens) {\r\n  if (!tokens || !tokens.length) {\r\n    return null;\r\n  }\r\n\r\n  var match = false;\r\n\r\n  function separate(str, _ref3) {\r\n    var _ref4 = _toArray(_ref3),\r\n        token = _ref4[0],\r\n        restTokens = _ref4.slice(1);\r\n\r\n    if (!token) {\r\n      return [str];\r\n    }\r\n\r\n    var list = str.split(token);\r\n    match = match || list.length > 1;\r\n    return list.reduce(function (prevList, unitStr) {\r\n      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));\r\n    }, []).filter(function (unit) {\r\n      return unit;\r\n    });\r\n  }\r\n\r\n  var list = separate(text, tokens);\r\n  return match ? list : null;\r\n}"]},"metadata":{},"sourceType":"module"}